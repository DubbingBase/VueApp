# Fastfile for DubbingBase Android app
# https://docs.fastlane.tools/

fastlane_version "2.219.0"

default_platform :android

# Import required fastlane actions
import "Constantsfile"
import "PrivateLanesfile"

platform :android do
  # Private lanes for shared functionality
  private_lane :setup_environment do
    # Set up environment variables for Supabase
    ENV["VITE_SUPABASE_URL"] = ENV["SUPABASE_URL"]
    ENV["VITE_SUPABASE_KEY"] = ENV["SUPABASE_ANON_KEY"]
    ENV["IONIC_PLATFORM"] = "android"

    UI.message("Environment variables configured for Supabase integration")
  end

  private_lane :install_dependencies do
    Dir.chdir("..") do
      UI.message("Installing dependencies with PNPM...")
      sh("pnpm install")
    end
  end

  private_lane :build_ionic_app do
    Dir.chdir("..") do
      UI.message("Building Ionic app...")
      sh("pnpm cap build android")
    end
  end

  private_lane :sync_capacitor do
    Dir.chdir("..") do
      UI.message("Syncing Capacitor for Android...")
      sh("pnpm cap sync android")
    end
  end

  private_lane :setup_keystore do
    UI.message("Setting up keystore for signing...")

    # Decode and setup keystore file
    key_store_path = "app/keystore.jks"
    File.write(key_store_path, Base64.decode64(ENV["KEYSTORE_FILE"]))

    # Set keystore properties for gradle
    ENV["ANDROID_KEYSTORE_PATH"] = key_store_path
    ENV["ANDROID_KEYSTORE_PASSWORD"] = ENV["KEYSTORE_PASSWORD"]
    ENV["ANDROID_KEY_ALIAS"] = ENV["KEY_ALIAS"]
    ENV["ANDROID_KEY_PASSWORD"] = ENV["KEY_PASSWORD"]
  end

  private_lane :increment_version do |options|
    current_version_code = options[:version_code] || 1
    current_version_name = options[:version_name] || "1.0"

    new_version_code = current_version_code + 1
    version_parts = current_version_name.split(".")
    new_version_name = "#{version_parts[0]}.#{version_parts[1].to_i + 1}"

    UI.message("Updating version: #{current_version_code} -> #{new_version_code}")
    UI.message("Updating version name: #{current_version_name} -> #{new_version_name}")

    # Update build.gradle
    build_gradle_path = "app/build.gradle"
    build_gradle_content = File.read(build_gradle_path)
    build_gradle_content.gsub!(/versionCode \d+/, "versionCode #{new_version_code}")
    build_gradle_content.gsub!(/versionName "[\d.]+"+/, "versionName \"#{new_version_name}\"")
    File.write(build_gradle_path, build_gradle_content)

    { version_code: new_version_code, version_name: new_version_name }
  end

  private_lane :build_android do |options|
    build_type = options[:build_type] || "Release"
    build_command = options[:aab_only] ? "bundle" : "assemble"

    UI.message("Building Android #{build_type}...")

    Dir.chdir(".") do
      gradle(
        task: "#{build_command}#{build_type}",
        build_type: build_type.downcase,
        properties: {
          "android.injected.signing.store.file" => ENV["ANDROID_KEYSTORE_PATH"],
          "android.injected.signing.store.password" => ENV["ANDROID_KEYSTORE_PASSWORD"],
          "android.injected.signing.key.alias" => ENV["ANDROID_KEY_ALIAS"],
          "android.injected.signing.key.password" => ENV["ANDROID_KEY_PASSWORD"]
        }
      )
    end
  end

  private_lane :handle_artifacts do |options|
    build_type = options[:build_type] || "release"
    aab_only = options[:aab_only] || false

    UI.message("Handling build artifacts...")

    # Handle AAB
    aab_path = "app/build/outputs/bundle/#{build_type}/app-#{build_type}.aab"
    if File.exist?(aab_path)
      UI.success("AAB created successfully: #{aab_path}")
    else
      UI.error("AAB not found at: #{aab_path}")
    end

    # Handle APK if not AAB only
    unless aab_only
      apk_path = "app/build/outputs/apk/#{build_type}/app-#{build_type}.apk"
      if File.exist?(apk_path)
        UI.success("APK created successfully: #{apk_path}")
      else
        UI.message("APK not found at: #{apk_path} (this may be normal)")
      end
    end
  end

  # Public lanes

  desc "Build debug version for development"
  lane :build_debug do
    begin
      setup_environment
      install_dependencies
      build_ionic_app
      sync_capacitor

      # Build debug APK only (no AAB for debug)
      build_android(build_type: "Debug", aab_only: true)
      handle_artifacts(build_type: "debug", aab_only: true)

      UI.success("Debug build completed successfully!")

    rescue => exception
      UI.error("Debug build failed: #{exception.message}")
      raise exception
    end
  end

  desc "Build release version for production"
  lane :build_release do
    begin
      setup_environment
      install_dependencies
      build_ionic_app
      sync_capacitor
      setup_keystore

      # Build release AAB and APK
      build_android(build_type: "Release", aab_only: false)
      handle_artifacts(build_type: "release", aab_only: false)

      UI.success("Release build completed successfully!")

    rescue => exception
      UI.error("Release build failed: #{exception.message}")
      raise exception
    end
  end

  desc "Build beta version for internal testing"
  lane :beta do
    begin
      UI.message("Building beta version for internal testing...")

      setup_environment
      install_dependencies
      build_ionic_app
      sync_capacitor
      setup_keystore

      # Increment version for beta
      current_version_code = 1 # This should be read from current build.gradle
      current_version_name = "1.0" # This should be read from current build.gradle
      new_version = increment_version(
        version_code: current_version_code,
        version_name: current_version_name
      )

      # Build beta AAB
      build_android(build_type: "Release", aab_only: true)
      handle_artifacts(build_type: "release", aab_only: true)

      # Upload to beta track (if configured)
      # upload_to_play_store(track: 'beta')

      UI.success("Beta build completed successfully! Version: #{new_version[:version_name]} (#{new_version[:version_code]})")

    rescue => exception
      UI.error("Beta build failed: #{exception.message}")
      raise exception
    end
  end

  desc "Build for local development"
  lane :local do
    begin
      UI.message("Building for local development...")

      setup_environment
      install_dependencies
      build_ionic_app
      sync_capacitor

      # Build debug APK for local testing
      build_android(build_type: "Debug", aab_only: true)
      handle_artifacts(build_type: "debug", aab_only: true)

      UI.success("Local build completed successfully!")

    rescue => exception
      UI.error("Local build failed: #{exception.message}")
      raise exception
    end
  end

  desc "Clean build artifacts"
  lane :clean do
    UI.message("Cleaning build artifacts...")

    Dir.chdir(".") do
      gradle(task: "clean")
    end

    Dir.chdir("..") do
      sh("pnpm cap build android --prod") if Dir.exist?("dist")
    end

    UI.success("Clean completed successfully!")
  end

  desc "Validate build configuration"
  lane :validate do
    UI.message("Validating build configuration...")

    # Check required environment variables
    required_env_vars = ["SUPABASE_URL", "SUPABASE_ANON_KEY"]
    missing_vars = []

    required_env_vars.each do |var|
      if ENV[var].nil? || ENV[var].empty?
        missing_vars << var
      end
    end

    if missing_vars.any?
      UI.error("Missing required environment variables: #{missing_vars.join(', ')}")
      raise "Environment validation failed"
    end

    # Check required files
    required_files = [
      File.expand_path("../../package.json", File.dirname(__FILE__)),
      File.expand_path("../app/build.gradle", File.dirname(__FILE__))
    ]
    missing_files = []

    required_files.each do |file|
      unless File.exist?(file)
        missing_files << file
      end
    end

    if missing_files.any?
      UI.error("Missing required files: #{missing_files.join(', ')}")
      raise "File validation failed"
    end

    UI.success("Build configuration validation passed!")
  end
end
